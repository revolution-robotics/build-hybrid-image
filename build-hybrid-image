#!/usr/bin/env bash
#
# @(#) build-hybrid-image
#
# Copyright Â© 2023 Revolution Robotics, Inc.
#
# Given an existing image, this script generates a hybrid by replacing
# the bootloader and devicetree with ones compiled from REVO
# Roadrunner sources.
#
: ${BMAPTOOL_CMD:='/usr/bin/bmaptool'}
: ${CAT_CMD:='/bin/cat'}
: ${CP_CMD:='/bin/cp'}
: ${DD_CMD:='/bin/dd'}
: ${FILE_CMD:='/usr/bin/file'}
: ${GZIP_CMD:='/usr/bin/gzip'}
: ${GREP_CMD:='/usr/bin/grep'}
: ${HEAD_CMD:='/usr/bin/head'}
: ${JQ_CMD:='/usr/bin/jq'}
: ${LOSETUP_CMD:='/sbin/losetup'}
: ${LS_CMD:='/bin/ls'}
: ${MKDIR_CMD:='/bin/mkdir'}
: ${MKFS_FAT_CMD:='/sbin/mkfs.fat'}
: ${MKE2FS_CMD:='/sbin/mke2fs'}
: ${MKIMAGE_CMD:='/usr/bin/mkimage'}
: ${MOUNT_CMD:='/sbin/mount'}
: ${MOUNT_IMAGE_CMD:="${HOME}/bin/mount.image"}
: ${MV_CMD:='/bin/mv'}
: ${PARTPROBE_CMD:='/sbin/partprobe'}
: ${READLINK_CMD:='/bin/readlink'}
: ${RM_CMD:='/bin/rm'}
: ${SED_CMD:='/bin/sed'}
: ${SFDISK_CMD:='/sbin/sfdisk'}
: ${SLEEP_CMD:='/bin/sleep'}
: ${SORT_CMD:='/usr/bin/sort'}
: ${STAT_CMD:='/usr/bin/stat'}
: ${SUDO_CMD:='/usr/bin/sudo'}
: ${SYNC_CMD:='/bin/sync'}
: ${TAR_CMD:='/bin/tar'}
: ${TEE_CMD:='/usr/bin/tee'}
: ${UMOUNT_IMAGE_CMD:="${HOME}/bin/umount.image"}
: ${XZ_CMD:='/usr/bin/xz'}
: ${ZSTD_CMD:='/usr/bin/zstd'}

# OS-agnstoic readlink for existent files/directories.
resolve-existing ()
{
    if $READLINK_CMD --version 2>&1 | $GREP_CMD -q 'coreutils'; then
        $READLINK_CMD -e -- "$@"
    else
        $READLINK_CMD -f N "$@"
    fi
}

get-compression-specs ()
{
    local image=$1
    local -n compression_specs=$2

    case $($FILE_CMD "$image" | $SED_CMD -E -e 's/^[^:]+: //') in
        *bzip2*) compression_specs=( "$BZIP2_CMD -dc"  '.bz2' ) ;;
        *gzip*)  compression_specs=( "$GZIP_CMD -dc" '.gz' ) ;;
        *lzip*)  compression_specs=( "$LZIP_CMD -dc" '.lz' ) ;;
        *LZMA*)  compression_specs=( "$LZMA_CMD -dc" '.lzma' ) ;;
        *lzop*)  compression_specs=( "$LZOP_CMD -dc" '.lzo') ;;
        *XZ*)    compression_specs=( "$XZ_CMD -dc" '.xz' ) ;;
        *Zip*)   compression_specs=( "$UNZIP_CMD -p" '.zip' ) ;;
        *Zstandard*) compression_specs=( "$ZSTD_CMD -dc" '.zst' ) ;;
        *'ISO 9660'*|*'DOS/MBR boot sector'*)
            compression_specs=( "$CAT_CMD" '' ) ;;
        *) compression_specs=( 'unknown' 'unknown' ) ;;
    esac

    if test ."${compression_specs[0]}" = .'unknown'; then
        echo "${FUNCNAME[0]}: ${image}: Unrecognized image." >&2
        return 1
    fi
}

regex-escape ()
{
    local regex=$1

    local escaped=''

    if ! escaped=$($SED_CMD -e 's/[][/\*+.|$]/\\&/g'  <<<"$regex"); then
        echo "${FUNCNAME[0]}: ${backing_image}: Escape failed." >&2
        return 1
    fi

    echo "$escaped"
}

backup-image ()
{
    local -n image=$1
    local -n specs=$2

    local decompressed_image=''

    if test ! -f "$image"; then
        case "${image##*.}" in
            bz2)  specs=( "$BZIP2_CMD -dc"  '.bz2' ) ;;
            gz)   specs=( "$GZIP_CMD -dc" '.gz' ) ;;
            lz)   specs=( "$LZIP_CMD -dc" '.lz' ) ;;
            lzma) specs=( "$LZMA_CMD -dc" '.lzma' ) ;;
            lzo)  specs=( "$LZOP_CMD -dc" '.lzo') ;;
            xz)   specs=( "$XZ_CMD -dc" '.xz' ) ;;
            zip)  specs=( "$UNZIP_CMD -p" '.zip' ) ;;
            zst)  specs=( "$ZSTD_CMD -dc" '.zst' ) ;;
        esac
    else
        get-compression-specs "$image" specs || return $?
    fi

    if test ."${specs[0]}" != .''; then
        decompressed_image=${image%${specs[1]}}
    else
        specs=( "$GZIP_CMD -dc" '.gz' )
        decompressed_image=$image
        image+=${specs[1]}
    fi

    if test -f "$decompressed_image"; then
        $MV_CMD -f "$decompressed_image"{,.old} || return $?
    fi

    if test -f "${decompressed_image}.bmap"; then
        $MV_CMD -f "${decompressed_image}.bmap"{,.old} || return $?
    fi

    if test -f "$image"; then
        $MV_CMD -f "$image"{,.old} || return $?
    fi

    image=$decompressed_image
}

copy-image ()
{
    local -n src_image=$1
    local -n dest_image=$2

    src_image=$(resolve-existing "$src_image") || return $?
    get-compression-specs "$src_image" specs || return $?

    local decompressed_src_image=''

    if test ."${specs[0]}" != ."$CAT_CMD"; then
        decompressed_src_image=${src_image%${specs[1]}}

        if test ! -f "$decompressed_src_image"; then
          n  echo "${FUNCNAME[0]}: ${src_image}: Decompressing..." >&2

            trap '$RM_CMD -f "$decompressed_src_image"; exit' 0 1 2 15

            ${specs[0]} "$src_image" >"$decompressed_src_image" || return $?

            trap - 0 1 2 15
        fi
    else
        specs=( "$GZIP_CMD -cd" '.gz' )
        decompressed_src_image=$src_image
        src_image+=${specs[1]}
    fi

    $CP_CMD "$decompressed_src_image" "$dest_image" || return $?
    dest_image=$(resolve-existing "$dest_image") || return $?
}

get-image-device ()
{
    local image=$1

    local -a devices=()

    mapfile -t devices < <(
        $LOSETUP_CMD -lJ  |
            $JQ_CMD -r '.loopdevices |
                .[] |
                select(
                    ."back-file" |
                     startswith("'"$image"'")
                ) | .name'
        )

    if (( ${#devices[*]} > 1 )); then
        echo "${FUNCNAME[0]}: ${image}: Ambiguous - use mount point instead." >&2
        return 1
    elif (( ${#devices[*]} < 1 )); then
        echo "${FUNCNAME[0]}: ${image}: Not loop attached." >&2
        return 2
    fi

    echo "${devices[0]}"
}

mount-image ()
{
    local args=$1
    local image=$2
    local -n mount_points=$3

    mapfile -t mount_points < <($MOUNT_IMAGE_CMD $args "$image")
}

replace-devicetree ()
{
    local root_mount_point=$1
    local parts_dir=$2

    $SUDO_CMD $RM_CMD -f "${root_mount_point}/"*.dtb || return $?
    $SUDO_CMD $CP_CMD "${parts_dir}/"*.dtb "${root_mount_point}/" || return $?

    $SUDO_CMD $RM_CMD -f "${root_mount_point}/"*.scr || return $?
    $SUDO_CMD $CP_CMD "${parts_dir}/boot.scr" "${root_mount_point}/" || return $?
}

zimage-to-uimage ()
{
    local -n mount_points=$1

    local z_image=${mount_points[0]}/zImage
    local u_image=${mount_points[0]}/uImage
    local kernel_release=$(
        $LS_CMD ${mount_points[1]}/lib/modules/ |
            $SORT_CMD -Vr |
            $HEAD_CMD -1
          ) || return $?

    if test -f "$z_image"; then
        $SUDO_CMD $MKIMAGE_CMD -A arm -O linux -C none -T kernel -a 0x80800000 -e 0x80800000 \
                  -n "$kernel_release" -d "$z_image" "$u_image" || return $?
        $SUDO_CMD $RM_CMD -f "$z_image"
    fi
}

add-boot-blocks ()
{
    local loop_device=$1
    local parts_dir=$2

    local spl_mmc=${parts_dir}/SPL.mmc
    local uboot_mmc=${parts_dir}/u-boot.img.mmc

    $SUDO_CMD $DD_CMD if="$spl_mmc" of="$loop_device" bs=1K seek=1 || return $?
    $SUDO_CMD $DD_CMD if="$uboot_mmc" of="$loop_device" bs=1K seek=69 || return $?
}

fix-systemd-networkd ()
{
    local -n destination_mount_points=$1

    local systemd_networkd_dir=${destination_mount_points[1]}/etc/systemd/system/systemd-networkd.service.d

    $SUDO_CMD $MKDIR_CMD -p "$systemd_networkd_dir" || return $?
    $SUDO_CMD $TEE_CMD "${systemd_networkd_dir}/override.conf" >/dev/null <<EOF
[Service]
ExecStartPre=/sbin/ip link set dev eth1 down ; /sbin/ip link set dev eth0 up ; /sbin/ip link set dev eth1 up
EOF
}

clean-up ()
{
    local src_image=$1
    local dest_image=$2
    local -n dest_specs=$3

    $UMOUNT_IMAGE_CMD --no-compress "$src_image" || return $?
    $UMOUNT_IMAGE_CMD "$dest_image" || return $?
    $BMAPTOOL_CMD create -o "${dest_image}.bmap" "${dest_image}" || return $?
    ${dest_specs[0]%% *} -c "${dest_image}" >"${dest_image}${dest_specs[1]}" || return $?
}


if test ."$0" = ."${BASH_SOURCE[0]}"; then
    set -o pipefail
    shopt -s lastpipe

    declare script=''
    declare script_dir=''
    declare script_name=''

    script=$(resolve-existing "$0") || exit $?
    script_dir=${script%/*}
    script_name=${script##*/}

    source "${script_dir}/build-builder-image"

    load-configuration "${script_dir}/${script_name}.conf" || exit $?

    declare loop_device=''

    declare -a partition_labels=( boot root recovery _ updates app data )
    declare -a partition_nos=( {1..3} {5..7} )

    declare -a hybrid_mount_points=()
    declare -a existing_mount_points=()
    declare -a hybrid_specs=()

    backup-image hybrid_img hybrid_specs
    copy-image existing_img hybrid_img

    trap '$UMOUNT_IMAGE_CMD "$hybrid_img" "$existing_img"; exit' 0 1 2 15

    mount-image ''  "$hybrid_img" hybrid_mount_points  || exit $?
    mount-image --no-decompress "$existing_img" existing_mount_points || exit $?
    loop_device=$(get-image-device "$hybrid_img") || exit $?
    "${script_dir}/container-build-parts" || exit $?

    declare parts_dir=''

    parts_dir=$(
        $LS_CMD -d "${build_products_dir}/"*'/output' |
            $SORT_CMD -Vr |
            $HEAD_CMD -1
                      ) || exit $?
    replace-devicetree "${hybrid_mount_points[0]}" "$parts_dir" || exit $?
    zimage-to-uimage hybrid_mount_points || exit $?
    add-boot-blocks "$loop_device" "$parts_dir" || exit $?
    fix-systemd-networkd hybrid_mount_points || exit $?
    clean-up "$existing_img" "$hybrid_img" hybrid_specs

    trap - 0 1 2 15
fi
