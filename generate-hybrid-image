#!/usr/bin/env bash
#
# @(#) generate-hybrid-image
#
# Copyright Â© 2023 Revolution Robotics, Inc.
#
# Given an existing image, this script generates a hybrid by replacing
# the bootloader and devicetree with ones compiled from REVO
# Roadrunner sources.
#
: ${BMAPTOOL_CMD:='/usr/bin/bmaptool'}
: ${CAT_CMD:='/bin/cat'}
: ${CP_CMD:='/bin/cp'}
: ${DD_CMD:='/bin/dd'}
: ${GZIP_CMD:='/usr/bin/gzip'}
: ${HEAD_CMD:='/usr/bin/head'}
: ${LOSETUP_CMD:='/sbin/losetup'}
: ${LS_CMD:='/bin/ls'}
: ${MKDIR_CMD:='/bin/mkdir'}
: ${MKFS_VFAT_CMD:='/sbin/mkfs.vfat'}
: ${MKFS_EXT4_CMD:='/sbin/mkfs.ext4'}
: ${MKIMAGE_CMD:='/usr/bin/mkimage'}
: ${MOUNT_CMD:='/sbin/mount'}
: ${MOUNT_IMAGE_CMD:="${HOME}/bin/mount.image"}
: ${MV_CMD:='/bin/mv'}
: ${PARTPROBE_CMD:='/sbin/partprobe'}
: ${READLINK_CMD:='/bin/readlink'}
: ${RM_CMD:='/bin/rm'}
: ${SFDISK_CMD:='/sbin/sfdisk'}
: ${SLEEP_CMD:='/bin/sleep'}
: ${SORT_CMD:='/usr/bin/sort'}
: ${STAT_CMD:='/usr/bin/stat'}
: ${SUDO_CMD:='/usr/bin/sudo'}
: ${TAR_CMD:='/bin/tar'}
: ${UMOUNT_IMAGE_CMD:="${HOME}/bin/umount.image"}

# OS-agnstoic readlink for existent files/directories.
resolve-existing ()
{
    if $READLINK_CMD --version 2>&1 | $GREP_CMD -q 'coreutils'; then
        $READLINK_CMD -e "$@"
    else
        $READLINK_CMD -f N "$@"
    fi
}

next-free-path ()
{
    local base=$1

    local next=$base
    local -i i=0

    while test -e "$next"; do
        next=${base}$(( ++i ))
    done

    echo "$next"
}

maybe-backup ()
{
    local image=$1

    if test -f "$image"; then
        $MV_CMD -f "$image"{,.old} || return $?
    fi

    if test -f "${image}.bmap"; then
        $MV_CMD -f "${image}.bmap"{,.old} || return $?
    fi

    if test -f "${image}.gz"; then
        $MV_CMD -f "${image}.gz"{,.old} || return $?
    fi
}

allocate-image ()
{
    local dest_image=$1
    local src_image=$2

    local -i src_size=0

    src_size=$($STAT_CMD --format=%s "$src_image") || return $?
    $DD_CMD if=/dev/zero of="$dest_image" bs="$src_size" seek=1 count=0 || return $?
}

duplicate-partition-table ()
{
    local src_image=$1
    local dest_image=$2

    $SFDISK_CMD --dump "$src_image" |
        $SFDISK_CMD --wipe=always "$dest_image" || return $?
}

loop-attach-image ()
{
    local image=$1

    local loop_device=''

    loop_device=$($SUDO_CMD $LOSETUP_CMD --nooverlap --find --show "$image") || return $?
    $SUDO_CMD $PARTPROBE_CMD "$loop_device" || return $?
    $SLEEP_CMD 2

    echo "$loop_device"
}

format-and-mount-device ()
{
    local loop_device=$1
    local -n _mount_points=$2
    local -n _partition_nos=$3
    local -n _partition_labels=$4

    local image_mount_basedir=''

    if test -d /run/media; then
        image_mount_basedir=/run/media/$USER
    else
        image_mount_basedir=/media/$USER
    fi

    local mount_point=''
    local -i i=0

    # Format and mount partitions
    for i in ${_partition_nos[*]}; do
        if test ! -e "${loop_device}p${i}"; then
            echo "${loop_device}p${i}: No such file or directory" >&2
            $SUDO_CMD $LOSETUP_CMD -d "$loop_device" || true
            $RM_CMD -f "$hybrid_img"
            return 1
        fi
        case $i in
            1) format_cmd="$MKFS_VFAT_CMD -n" ;;
            *) format_cmd="$MKFS_EXT4_CMD -L" ;;
        esac

        $SUDO_CMD $format_cmd  "${_partition_labels[i - 1]}" "${loop_device}p${i}" || return $?
        mount_point=$(next-free-path "${image_mount_basedir}/${_partition_labels[i - 1]}")
        $SUDO_CMD $MKDIR_CMD -p "$mount_point" || return $?
        $SUDO_CMD $MOUNT_CMD "${loop_device}p${i}" "$mount_point" || return $?
        _mount_points+=( "$mount_point" )
    done
}

mount-image ()
{
    local image=$1
    local -n mount_points=$2

    $MOUNT_IMAGE_CMD "$image" |
        mapfile -t mount_points || return $?
}

copy-file-systems ()
{
    local -n source_mount_points=$1
    local -n destination_mount_points=$2

    local -i i=0

    for i in ${!source_mount_points[*]}; do
        $SUDO_CMD $TAR_CMD -C "${source_mount_points[i]}" -cf - . |
            $SUDO_CMD $TAR_CMD -C "${destination_mount_points[i]}" -xf -
    done
}

zimage-to-uimage ()
{
    local -n mount_points=$1

    local z_image=${mount_points[0]}/zImage
    local u_image=${mount_points[0]}/uImage
    local kernel_release=$(
        $LS_CMD ${mount_points[1]}/lib/modules/ |
            $SORT_CMD -Vr |
            $HEAD_CMD -1
          ) || return $?

    $SUDO_CMD $MKIMAGE_CMD -A arm -O linux -C none -T kernel -a 0x80800000 -e 0x80800000 \
            -n "$kernel_release" -d "$z_image" "$u_image" || return $?
    $SUDO_CMD $RM_CMD -f "$z_image"
}

add-boot-blocks ()
{
    local loop_device=$1
    local parts_dir=$2

    local spl_mmc=${parts_dir}/SPL.mmc
    local uboot_mmc=${parts_dir}/u-boot.img.mmc

    $SUDO_CMD $DD_CMD if="$spl_mmc" of="$loop_device" bs=1K seek=1 || return $?
    $SUDO_CMD $DD_CMD if="$uboot_mmc" of="$loop_device" bs=1K seek=69 || return $?
}

replace-devicetree ()
{
    local root_mount_point=$1
    local parts_dir=$2

    $SUDO_CMD $RM_CMD -f "${root_mount_point}/"*.dtb || return $?
    $SUDO_CMD $CP_CMD "${parts_dir}/"*.dtb "${root_mount_point}/" || return $?

    $SUDO_CMD $RM_CMD -f "${root_mount_point}/"*.scr || return $?
    $SUDO_CMD $CP_CMD "${parts_dir}/"*.scr "${root_mount_point}/" || return $?
}

bmap-and-compress ()
{
    local image=$1

    $BMAPTOOL_CMD create -o "${image}.bmap" "${image}" || return $?
    $GZIP_CMD -c "${image}" >"${image}.gz"
}

clean-up ()
{
    local image1=$1
    local image2=$2

    $UMOUNT_IMAGE_CMD "$image1" || true
    $UMOUNT_IMAGE_CMD "$image2"
}

if test ."$0" = ."${BASH_SOURCE[0]}"; then
    set -o pipefail
    shopt -s lastpipe

    declare script=''
    declare script_dir=''

    script=$(resolve-existing "$0")
    script_dir=${script%/*}

    source "${script_dir}/build-builder-image"

    load-configuration "${script_dir}/generate-hybrid-image.conf" || exit $?

    declare loop_device=''

    declare -a partition_labels=( boot root recovery _ updates app data )
    declare -a partition_nos=( {1..3} {5..7} )

    declare -a hybrid_mount_points=()
    declare -a miw_mount_points=()

    maybe-backup "$hybrid_img"
    allocate-image "$hybrid_img" "$miw_img" || exit $?
    duplicate-partition-table "$miw_img" "$hybrid_img" || exit $?
    loop_device=$(loop-attach-image "$hybrid_img") || exit $?

    trap '$UMOUNT_IMAGE_CMD "$hybrid_img" "$miw_img"; exit' 0 1 2 15

    format-and-mount-device "$loop_device" hybrid_mount_points \
                            partition_nos partition_labels || exit $?
    mount-image "$miw_img" miw_mount_points || exit $?
    copy-file-systems miw_mount_points hybrid_mount_points || exit $?
    zimage-to-uimage hybrid_mount_points || exit $?
    "${script_dir}/container-build-parts" || exit $?

    declare parts_dir=''

    parts_dir=$(
        $LS_CMD -d "${build_products_dir}/"*'/output' |
            $SORT_CMD -Vr |
            $HEAD_CMD -1
                      ) || exit $?
    add-boot-blocks "$loop_device" "$parts_dir" || exit $?
    replace-devicetree "${hybrid_mount_points[0]}" "$parts_dir" || exit $?
    bmap-and-compress "$hybrid_img" || exit $?
    clean-up  "$hybrid_img" "$miw_img"

    trap - 0 1 2 15
fi
